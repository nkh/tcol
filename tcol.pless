
bind custom	tcol	j		move_down		"scroll down"
bind custom	tcol	DOWN		move_down		"scroll down"
bind custom	tcol	UP		move_up 		"scroll up"
bind custom	tcol	k		move_up 		"scroll up"
bind custom	tcol	RIGHT		move_right		"move right"
bind custom	tcol	l		move_right		"move right"
bind custom	tcol	LEFT		move_left		"move left"
bind custom	tcol	h		move_left		"move left"

bind custom	tcol	yy		copy_to_clipboard	"copy to clipboard"
bind custom	tcol	yq		copy_and_quit		"copy to clipboard and quit"
bind custom	tcol	Q		quit_no_output		"quit without displaying color data"
bind custom	tcol	q		quit			"quit"
bind custom	tcol	QUESTION_MARK	k_bindings		"show bindings"
bind custom	tcol	:h		display_help		"display help"

bind custom	tcol	b		pick_background		"pick background"
bind custom	tcol	f		pick_foreground		"pick foreground"
bind custom	tcol	cb		color_black		"use black color"
bind custom	tcol	cw		color_white		"use white color"
bind custom	tcol	cr		reverse_colors		"reverse"
bind custom	tcol	r1		restore_colors_1	"restore #1"
bind custom	tcol	r2		restore_colors_2	"restore #2"
bind custom	tcol	r3		restore_colors_3	"restore #3"
bind custom	tcol	r4		restore_colors_4	"restore #4"

bind custom	tcol	n		normal_mode		"normal mode"
bind custom	tcol	p		pick_mode		"pick mode"
bind custom	tcol	mm		change_mode		"modification mode"
bind custom	tcol	a		alternate_mode		"alternate mode"

bind custom	tcol	m1		save_colors_1		"save #1"
bind custom	tcol	m2		save_colors_2		"save #2"
bind custom	tcol	m3		save_colors_3		"save #3"
bind custom	tcol	m4		save_colors_4		"save #4"
bind custom	tcol	mc		change_color_fzf	"set change color"
bind custom	tcol	mf		color_fzf		"set modification color"
bind custom	tcol	mF		color_fzf_all		"set all modification colors"
bind custom	tcol	mu		color_user		"chose from user colors"
bind custom	tcol	mU		color_user_all		"chose all from user colors"
bind custom	tcol	mn		color_user_name		"chose from user colors by name"
bind custom	tcol	mN		color_user_name_all	"chose all from user colors by name"
bind custom	tcol	s1		select_color1		"select color 1"
bind custom	tcol	s2		select_color2		"select color 2"
bind custom	tcol	s3		select_color3		"select color 3"
bind custom	tcol	s4		select_color4		"select color 4"

current_swash=1            # background color / foreground color
swash_x=0       swash_y=0  # position in color swash
pane_0_x=1      pane_0_y=1 # position in preview pane 

color_fg=15     color_bg=0
mcolors_index=0 mcolors=() mcolors_c=() mcolors_fg=(0 0 0 0) mcolors_bg=(0 0 0 0)

mode=normal

pick_mode()      { mode=pick   ; list ; }
normal_mode()    { mode=normal ; list ; }
change_mode()    { mode=change ; list ; }
alternate_mode() { [[ $mode == pick ]] && return ; [[ $mode == normal ]] && mode=change || mode=normal ; list ; }

pick_background()
{
current_swash=0
color_pos=$(get_color_pos $color_bg)

swash_y=${color_pos%:*} swash_x=${color_pos#*:}
list
}

pick_foreground()
{
current_swash=1
color_pos=$(get_color_pos $color_fg)

swash_y=${color_pos%:*} swash_x=${color_pos#*:}
list
}

move_left()         { move_left_$mode ; }
move_right()        { move_right_$mode ; }
move_up()           { move_up_$mode ; }
move_down()         { move_down_$mode ; }

move_left_pick()    { ((pane_0_x > 1 && pane_0_x--))                     ; pick_pane_0_color ; list ; }
move_right_pick()   { ((pane_0_x < (pane_columns[0] - 1) && pane_0_x++)) ; pick_pane_0_color ; list ; }
move_up_pick()      { ((pane_0_y > 1 && pane_0_y--))                     ; pick_pane_0_color ; list ; }
move_down_pick()    { ((pane_0_y < bottom_line && pane_0_y++))           ; pick_pane_0_color ; list ; }

move_left_change()  { move_left_normal ; }
move_right_change() { move_right_normal ; }
move_up_change()    { move_up_normal ; }
move_down_change()  { move_down_normal ; }

move_left_normal()  { ((swash_x > 0 && swash_x--))  ; set_color ; list ; }
move_right_normal() { ((swash_x < 17 && swash_x++)) ; set_color ; list ; }
move_up_normal()    { ((swash_y > 0 && swash_y--))  ; set_color ; list ; }
move_down_normal()  { ((swash_y < 14 && swash_y++)) ; set_color ; list ; }

color_fzf()
{
exec 2>&9
declare -n array_ref="source0"
readarray -t fzf_color < <(printf "%s\n" "${array_ref[@]}" | ansi_extract_colors | awk '!seen[$1]++' | fzf --ansi -m)
exec 2>"$fs/log"

mcolors[mcolors_index]="${fzf_color[0]}"

echo -en '\e[?1049h' ; stty -echo ; tput civis ; list
}

color_fzf_all()
{
exec 2>&9
declare -n array_ref="source0"
readarray -t fzf_color < <(printf "%s\n" "${array_ref[@]}" | ansi_extract_colors | awk '!seen[$1]++' | fzf --ansi -m)
exec 2>"$fs/log"

for c in {0..3} ; do [[ "${fzf_color[c]}" ]] && mcolors[c]="${fzf_color[c]}" ; done

echo -en '\e[?1049h' ; stty -echo ; tput civis ; list
}

color_user()
{
exec 2>&9
readarray -t fzf_color < <(ansi_user_colors)
exec 2>"$fs/log"

mcolors[mcolors_index]="${fzf_color[0]}"

echo -en '\e[?1049h' ; stty -echo ; tput civis ; list
}

color_user_all()
{
exec 2>&9
readarray -t fzf_color < <(ansi_user_colors)
exec 2>"$fs/log"

for c in {0..3} ; do [[ "${fzf_color[c]}" ]] && mcolors[c]=${fzf_color[c]} ; done

echo -en '\e[?1049h' ; stty -echo ; tput civis ; list
}

color_user_name()
{
exec 2>&9
readarray -t fzf_color < <(ansi_user_colors_by_name)
exec 2>"$fs/log"

mcolors[mcolors_index]="${fzf_color[0]}"

echo -en '\e[?1049h' ; stty -echo ; tput civis ; list
}

color_user_name_all()
{
exec 2>&9
readarray -t fzf_color < <(ansi_user_colors_by_name)
exec 2>"$fs/log"

for c in {0..3} ; do [[ "${fzf_color[c]}" ]] && mcolors[c]=${fzf_color[c]} ; done

echo -en '\e[?1049h' ; stty -echo ; tput civis ; list
}

color_black ()     { swash_y=0 ; swash_x=0  ; set_color ; list ; }
color_white ()     { swash_y=0 ; swash_x=17 ; set_color ; list ; }
reverse_colors()   { t_color=$color_fg ; color_fg=$color_bg ; color_bg=$t_color ; ((current_swash)) && pick_foreground || pick_background ; }

save_colors_1()    { mcolors_bg[0]=$color_bg ; mcolors_fg[0]=$color_fg ; mcolors[0]=$color ; mcolors_index=0 ; list ; }
save_colors_2()    { mcolors_bg[1]=$color_bg ; mcolors_fg[1]=$color_fg ; mcolors[1]=$color ; mcolors_index=1 ; list ; }
save_colors_3()    { mcolors_bg[2]=$color_bg ; mcolors_fg[2]=$color_fg ; mcolors[2]=$color ; mcolors_index=2 ; list ; }
save_colors_4()    { mcolors_bg[3]=$color_bg ; mcolors_fg[3]=$color_fg ; mcolors[3]=$color ; mcolors_index=3 ; list ; }
                                           
restore_colors_1() { color_bg=${mcolor_bg[0]} ; color_fg=${mcolor_fg[0]} ; list ; }
restore_colors_2() { color_bg=${mcolor_bg[1]} ; color_fg=${mcolor_fg[1]} ; list ; }
restore_colors_3() { color_bg=${mcolor_bg[2]} ; color_fg=${mcolor_fg[2]} ; list ; }
restore_colors_4() { color_bg=${mcolor_bg[3]} ; color_fg=${mcolor_fg[3]} ; list ; }

set_color()
{
(( t_color = color_swash[18 * swash_y + swash_x] ))
((current_swash)) && color_fg=$t_color || color_bg=$t_color

[[ $mode == change ]] &&  mcolors_c[mcolors_index]="48;5;$color_bg;38;5;$color_fg"
}

pick_pane_0_color()
{
array_name=${line_blocks[0]} ; declare -n array_ref="$array_name"

read -r -d '' ansi_extract_perl <<'EOC'
use strict ; use warnings ; use Encode ;

my ($color, $text_length) = (0, 0) ;

for my $chunk ( split /(\e(?:\[(?:[0-9;]*)m))/, $ARGV[0])
	{
	if($chunk =~ /\e(\[([0-9;]*)m)/)
		{
		$color = $2 ;
		}
	else
		{
		$text_length += length(decode('utf8', $chunk)) ;
		if($text_length > ($ARGV[1] // 0))
			{
			print "$color\n" ;
			exit
			}
		}
	}

print "$color\n"
EOC

color_pick="$(perl -e "$ansi_extract_perl" "${array_ref[$(( pane_0_y - 1 ))]}" $((pane_0_x - 1)))"
}

select_color1() { mcolors_index=0 ; }
select_color2() { mcolors_index=1 ; }
select_color3() { mcolors_index=2 ; }
select_color4() { mcolors_index=3 ; }

change_color_fzf()
{
exec 2>&9
readarray -t fzf_color < <(ansi_user_colors)
exec 2>"$fs/log"

mcolors_c[color_index]=${fzf_color[0]}

echo -en '\e[?1049h' ; stty -echo ; tput civis ; list
}

overlay_text()
{
((swash_pane_x = pane_columns[0] + 1))

[[ $mode == normal || $mode == change ]] && 
	{ color="48;5;$color_bg;38;5;$color_fg" ; rcolor="48;5;$color_fg;38;5;$color_bg" ; }

[[ $mode == pick ]] && color=$color_pick

echo -en "\e[1;${swash_pane_x}H\e[${color}m                  "
echo -en "\e[2;${swash_pane_x}H\e[${color}m   Lorem  Ipsum   "
echo -en "\e[3;${swash_pane_x}H\e[${color}m                  "

for i in {0..3} ; do
	echo -en "\e[$((5 + i));${swash_pane_x}H\e[${mcolors[i]}m   Lorem \e[${mcolors_c[i]}m Ipsum   $RESET"
done

[[ $mode == normal || $mode == change ]] &&
	{
	((color_swash_y = 10 + swash_y , color_swash_x = swash_pane_x + swash_x))
	echo -en "\e[$color_swash_y;${color_swash_x}H${RESET}X"
	}

[[ $mode == pick ]] && echo -en "\e[$pane_0_y;${pane_0_x}H${RESET}X" 

echo -en "\e[25;${swash_pane_x}H\e[38;5;240m[${color}$RESET"
}

get_pane_text()
{
local text_ref=$1 top_line="$2" line="$3" pline="$4" source_index="$5" array_name="$6"

declare -n text="$text_ref"
declare -n array_ref="$array_name"

((line--)) # display line indexed from 1
((line < ${#array_ref[@]})) && text="${array_ref[line]}" || text="${padding[source_index]}"

[[ $mode == change ]] &&
	{
	for i in {0..3} ; do
		[[ "${mcolors_c[i]}" ]] && text=${text//${mcolors[i]}/${mcolors_c[i]}}
	done
	
	text="$text"
	}
}

quit_no_output()    { restore_screen ; exit ; }
quit()              { restore_screen ; display_colors ; exit ;}
copy_and_quit()     { copy_to_clipboard ; quit_no_output ; }
copy_to_clipboard() { echo -n "${color}" | xsel -i -b -p -s ; }


display_colors()
{

[[ "${e[--oc]}" ]] && copy_to_clipboard

[[ -z "${e[--no-color-output]}" ]] && 
	{
	echo -e "\e[${color}m${color}$RESET"

	for i in {0..3} ; do
		[[ "${mcolors[i]}" ]] && 
			{
			echo -en "$((i +1)): \e[${mcolors[i]}m${mcolors[i]}$RESET"
			[[ "${mcolors[i]}" != "${mcolors_c[i]}" ]] && echo -en " -> \e[${mcolors_c[i]}m${mcolors_c[i]}$RESET"
			echo
			}
	done
	}
}

get_color_pos()
{
cell=0
for (( l = 0 ; l < 15 ; l++)) ; do
	for (( c = 0 ; c < 18 ; c++))
		do
			(( $1 == color_swash[$cell] )) && { echo $l:$c ; break 2 ; }
			(( cell++ ))
		done
done
}

display_help() { clear ; tcol -h | $PAGER ; echo -en '\e[?1049h' ; stty -echo ; tput civis ; list ; }

color_swash()
{
for i in {1..9} ; do echo ; done

color_index=0

for l in {0..14} ; do
	for c in {0..17} ; do echo -en "\e[48;5;${color_swash[color_index]}m " ;  ((color_index++)) ; done
	echo -e "\e[0m";
done

}

color_swash=(
0   0   0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15
232 233 234 235 236 237 238 239 240 241 242 243 235 241 243 230 136 130
244 245 246 247 248 249 250 251 252 253 254 255 160 168 98  32  36  100 
16  17  18  52  53  54  88  89  90  124 125 126 160 161 162 196 197 198
22  23  24  58  59  60  94  95  96  130 131 132 166 167 168 202 203 204
28  29  30  64  65  66  100 101 102 136 137 138 172 173 174 208 209 210
34  35  36  70  71  72  106 107 108 142 143 144 178 179 180 214 215 216
40  41  42  76  77  78  112 113 114 148 149 150 184 185 186 220 221 222
46  47  48  82  83  84  118 119 120 154 155 156 190 191 192 226 227 228
19  20  21  55  56  57  91  92  93  127 128 129 163 164 165 199 200 201
25  26  27  61  62  63  97  98  99  133 134 135 169 170 171 205 206 207
31  32  33  67  68  69  103 104 105 139 140 141 175 176 177 211 212 213
37  38  39  73  74  75  109 110 111 145 146 147 181 182 183 217 218 219
43  44  45  79  80  81  115 116 117 151 152 153 187 188 189 223 224 225
49  50  51  85  86  87  121 122 123 157 158 159 193 194 195 229 230 231
)

# vim: set ft=bash:

